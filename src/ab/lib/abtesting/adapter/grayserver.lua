---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by guoguo.
--- DateTime: 2020/11/21 16:15
---

local modulename = "abtestingAdapterGrayServer"

local _M = { _VERSION = "0.0.1" }
local mt = { __index = _M }

local systemConf    = require('abtesting.utils.init')
local utils         = require('abtesting.utils.utils')
local log			= require('abtesting.utils.log')
local ERRORINFO     = require('abtesting.error.errcode').info
local cjson         = require('cjson.safe')

local pageMod          = require('abtesting.utils.page')




local k_name = 'name'
local k_switch = "switch"

local grayServerPrefix = systemConf.prefixConf.graySwitchPrefix

_M.new = function(self, database, baseLibrary)
    if not database then
        error{ERRORINFO.PARAMETER_NONE, 'need avaliable redis db'}
    end
    if not baseLibrary then
        error{ERRORINFO.PARAMETER_NONE, 'need avaliable grayserver baselib'}
    end

    self.database     = database
    self.baseLibrary  = baseLibrary

    return setmetatable(self, mt)
end


_M.set = function(self, grayServer)
    local database  = self.database
    local prefix = grayServerPrefix
    local serverNames = {}
    database:init_pipeline()

    local i=1;
    for _, v in pairs(grayServer) do
        database:hset(prefix, v[k_name], v[k_switch])
        serverNames[i] = 'gray server '..v[k_name];

        i = i+1;
    end
    local ok, err = database:commit_pipeline()
    if not ok then
        error{ERRORINFO.REDIS_ERROR, err}
    end
    return serverNames
end

_M.check = function(self, grayServer)
    for _, v in pairs(grayServer) do
        local name      = v[k_name]
        local switch  = v[k_switch]

        if not name or not switch then
            local info = ERRORINFO.GRAYSERVER_INPUT_ERROR
            local desc = ' need '..k_name..' and '..k_switch
            return {false, info, desc}
        end
    end
    return {true}
end

_M.del = function(self, serverName)
    local database      = self.database
    local baseLibrary   = self.baseLibrary

    local ok, err = database:hdel(baseLibrary,serverName)
    if not ok then
        error{ERRORINFO.REDIS_ERROR, err}
    end
end

_M.get = function(self,serverName)
    local database = self.database
    local baseLibrary = self.baseLibrary
    local ret = {}
    local switch,err = database:hget(baseLibrary,serverName)
    ngx.log(ngx.DEBUG,switch)
    if not switch then
        error{ERRORINFO.REDIS_ERROR,err}
    elseif switch == ngx.null then
        return ret
    end

    ret.name = serverName
    ret.switch = switch
    return ret
end

_M.loadAll = function(self)
    local database = self.database
    local baseLibrary = self.baseLibrary
    local serverNames,err = database:hkeys(baseLibrary)
    for i=1,#serverNames do
        ngx.log(ngx.DEBUG,serverNames[i])
    end
    if not serverNames then
        error{ERRORINFO.REDIS_ERROR,err}
    end

    local grayServer = {}
    for i=1,#serverNames do
        local serverSwitch,err = database:hget(baseLibrary,serverNames[i])
        if not serverSwitch then error{ERRORINFO.REDIS_ERROR, err} end
        grayServer[serverNames[i]] = serverSwitch
    end
    ngx.log(ngx.DEBUG,cjson.encode(grayServer))
    return grayServer
end

_M.pageList = function(self,page,size)
    local database = self.database
    local baseLibrary = self.baseLibrary
    local serverNames,err = database:hkeys(baseLibrary)
    local page = page or 1
    local size = size or 20
    local startIndex = (page-1)*size + 1
    local endIndex = page*size

    ngx.log(ngx.DEBUG,startIndex,endIndex)

    local grayServer = {}
    local hkeys = {}

    if not serverNames then
        return grayServer
    end
    local maxIndex = #serverNames
    if endIndex > maxIndex then
        endIndex = maxIndex
    end
    local k = 1
    for i=startIndex,endIndex do
        hkeys[k] = serverNames[i]
        k = k +1
    end

    for k,v in pairs(hkeys) do
        ngx.log(ngx.DEBUG,hkeys[k])
        ngx.log(ngx.DEBUG,k)
        local serverSwitch,err = database:hget(baseLibrary,hkeys[k])
        if not serverSwitch then error{ERRORINFO.REDIS_ERROR, err} end
        local single = {}
        single.name = hkeys[k]
        single.switch = serverSwitch
        grayServer[k]= single
    end
    ngx.log(ngx.DEBUG,cjson.encode(grayServer))
    local pageMod = pageMod:new(page,size,#serverNames,grayServer)
    local page = pageMod:page()
    ngx.log(ngx.DEBUG,cjson.encode(page))
    return page
end



return _M

